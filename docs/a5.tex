\documentclass{article}
\usepackage{todonotes}
\usepackage{listings}
\usepackage{amsmath}
\usepackage[margin=0.5in]{geometry}

\title{CS 444 - A5}
\author{Jacob Abrahams - 20370104\\ Alexander Maguire - 20396195}

\usepackage{color}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{orange}{rgb}{0.82,0.38,0}
\definecolor{dkred}{rgb}{0.65,0.0,0}

\lstdefinelanguage{scala}{
  morekeywords={abstract,case,catch,class,def,%
    do,else,extends,false,final,finally,%
    for,if,implicit,import,match,mixin,%
    new,null,object,override,package,%
    private,protected,requires,return,sealed,%
    super,this,throw,trait,true,try,%
    type,val,var,while,with,yield,Some,None,Option,Before,After,visit,map,foreach,flatMap,Target,AnonLabel,NamedLabel},
  otherkeywords={=>,<-,<\%,<:,>:,\#,@}, sensitive=true, morecomment=[l]{//}, morecomment=[n]{/*}{*/}, morestring=[b]",
  morestring=[b]', morestring=[b]""" }

\lstset{frame=tb, language=scala, aboveskip=3mm, belowskip=3mm, showstringspaces=false, columns=flexible,
  basicstyle={\small\ttfamily}, numbers=none, numberstyle=\tiny\color{gray}, keywordstyle=\color{blue},
  commentstyle=\color{dkgreen}, stringstyle=\color{mauve}, frame=single, breaklines=true, breakatwhitespace=true
  tabsize=3 }

\lstdefinelanguage{nasm}{
    otherkeywords={},
    keywords=[0]{dword,word,byte,call,leave,ret},
    keywords=[1]{eax,ebx,ecx,edx,esp,ebp,eip},sensitive=true,morecomment=[l]{;},morestring=[b]",
    moredelim=[is][\color{red}\ttfamily]{<}{>},
    moredelim=[is][\color{dkred}\ttfamily]{\{}{\}},
    moredelim=[s][\color{orange}\ttfamily]{[}{]}, morestring=[b]' }

\lstset{frame=tb, language=nasm, aboveskip=3mm, belowskip=3mm, showstringspaces=false, columns=flexible,
    basicstyle={\small\ttfamily}, numbers=none, numberstyle=\tiny\color{gray}, keywordstyle=[0]\color{blue},
    keywordstyle=[1]\color{mauve},
  commentstyle=\color{dkgreen}, stringstyle=\color{mauve}, frame=single, breaklines=true, breakatwhitespace=true
  tabsize=3 }

\begin{document}

\newcommand\type[1]{\texttt{#1}}
\newcommand\func[1]{\texttt{#1}}
\newcommand\code[1]{\texttt{#1}}
\renewcommand\value[1]{\texttt{#1}}
\newcommand\source[2]{See: \texttt{src/#1.scala}::\type{#2} \\}
\newcommand\testsrc[1]{See: \texttt{test/#1.scala} \\}

\maketitle


\section{Design}

\subsection{Target Infrastructure}
We created a class which represented a codegen target; generally this corresponded to a compilation unit, but one also
existed for globals. Each target tracked symbols imported and exported, and had three sections code could be generated
in: \type{text}, \type{data} and \type{rodata}. Each section had an \func{emit} method, which took a variadic number of
\type{Instruction} arguments. Originally \type{Instruction}s were intended to provide type-safety to our assembly -- if it
compiled in Scala, we could be assured it would assemble as well -- but this quickly proved to be too large an
undertaking for our shaky knowledge of x86. The end result provides special support for labels, but for the most part
allows strings to be implicitly transformed into \type{Instruction}s.

The following code sample, which creates allocators for classes, illustrates the basic usage of \type{Target}s:

\begin{lstlisting}[language=Scala]
// Inform the assembly we will export this label
Target.file.export(c.allocLabel)
Target.text.emit( // Target.text automatically resolves to Target.file.text
  c.allocLabel,    // procedure name
  Prologue(),      // function prologue
  s"mov eax, ${c.allocSize + 4}",
  "call __malloc",
  s"mov [eax], dword ${c.classId}",
  "push eax",
  s"call ${c.initLabel}", // call the object initializer
  "pop ebx",
  Epilogue()
  )
\end{lstlisting}
\source{codegen/Generator}{Generator\#emit:234}


\subsection{Code Generation}
mention generatorutils
exceptions

% syntax highlighting fun:
%   wrap global label defns with <>
%   wrap local label defs with {}
\begin{lstlisting}[language=nasm]
<_#.Codegen@static@test#:>
push ebp
mov ebp, esp
    sub esp, 4
    ; init var x
    mov ebx, 5
    mov eax, ebx
    call __aalloc
    mov [eax], dword 31
    mov ebx, eax
    mov [ebp+-4], ebx
    ; load var x
    mov ebx, [ebp+-4]
    push ebx
    mov ebx, 0
    mov ecx, ebx
    pop ebx
    cmp ebx, 0
jne .__anon_352.not_null
call __exception
{.__anon_352.not_null:}
    push dword [ebx]
    cmp ecx, [ebx+4]
jl .__anon_353.idx_bounded
call __exception
{.__anon_353.idx_bounded:}
    imul ecx, 4
    add ebx, ecx
    add ebx, 8
    push ebx
    call _#.Codegen##new
    push eax
    call _#.Codegen##ctor
    add esp, 0
    pop ebx
    pop ecx
    ; *ecx = ebx
    mov [ecx], ebx
    ; array store exceptions
    cmp ebx, 0
    jne .__anon_354.not_null
    mov ebx, 0
    jmp .__anon_355
{.__anon_354.not_null:}
    mov eax, [ebx]
    pop ecx
    push ebx
    mov ebx, ecx
    call __instanceof
    cmp ebx, 0
jne .__anon_356.store_ok
call __exception
{.__anon_356.store_ok:}
    pop ebx
{.__anon_355:}
    mov ebx, 0
leave
ret
\end{lstlisting}

\subsection{Runtime Type-Information}
primitives do not keep track; but we do reserve one for them
first byte of a reference
no meaningful map between ids and types


\subsubsection{Instanceof and Casting}
global hierarchy table
lookup your type id
says what you're allowed to be cast to
linear scan through


\subsection{Virtual Invokes}

\subsection{Interface Invokes}






\section{Challenges}
\begin{itemize}
    \item One issue we started butting heads against in A4, but which really came back to bite us was that we were
        storing metadata in the AST, things like giving type names a reference to the type definition to which they
        resolve. While this works well for static ASTs, it quickly falls apart when rewriting an immutable tree. As a
        result, our AST became significantly fractured, with newer rewrites having backwards references to old trees and
        similar issues. Luckily this didn't cause too many issues, since the things we were referencing were unlikely to
        be significantly rewritten.

        In particular, however, this made generating runtime type IDs quite an ordeal, since we wanted them to be
        automatic, ordered and contiguous. In the end, we simply generated all type IDs immediately before codegen, but
        we considered this to be an inelegant solutioIn the end, we simply generated all type IDs immediately before
        codegen, but we considered this to be an inelegant solution.
    \item Similarly, the natural functional approach to resolving inherited methods is a recursive fold over your
        ancestors, but this proved not to create a deterministically useful list of methods for creating a vtable --
        overriding a parent's method updated the method to be at the \textit{end} of the vtable, not in the original
        location. In the end we used some terrifyingly arcane functional wizardry to ensure a consistent ordering.
        Despite having not done the analysis, we suspect the approach to be roughly on the order of $O(\text{terrible})$.
\end{itemize}




\section{Testing}
One of our earliest implementations for A5 was extending the parser to allow for a special debug command, which took a
string literal and would generate code to print it out at runtime. Such an approach allowed took only a few minutes to
implement, but immediately allowed us to begin debugging complicated control-flow before the entire ecosystem was in
place.

Unfortunately, our Scalatest suite seemed incapable of keeping up with our development on this assignment, mostly in
that it was designed to test Scala, and not arbitrary system commands. Getting it to work with marmoset tests on earlier
assignments was a significant undertaking, and we didn't feel it worthwhile to jump through the requisite hoops in order
to get it assembling, linking and comparing the output of our generated code.

Instead, we meticulously tested each feature as it was implemented, relying on the fact that code generation is already
quite modularized; any regressions we were likely to cause wouldn't be subtle, and would probably cause a segfault in
most programs. We facilitated this by creating a special debug mode for the compiler which would run iteratively in a
REPL with identical parameters each time, so code generation of test programs was quite painless.

Additionally, we wrote code which would generate C++ structs for our Joos types, which was invaluable when debugging
with GDB. We were afforded the ability to typecast arbitrary pointers to our types and see if they lined up, since most
bugs we encountered were caused by data not being what we expected it to be.

\end{document}

