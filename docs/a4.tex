\documentclass{article}
\usepackage{todonotes}
\usepackage{listings}
\usepackage[margin=0.5in]{geometry}


\title{CS 444 - A4}
\author{Jacob Abrahams - 20370104\\ Alexander Maguire - 20396195}

\lstdefinelanguage{scala}{
  morekeywords={abstract,case,catch,class,def,%
    do,else,extends,false,final,finally,%
    for,if,implicit,import,match,mixin,%
    new,null,object,override,package,%
    private,protected,requires,return,sealed,%
    super,this,throw,trait,true,try,%
    type,val,var,while,with,yield,Some,None,Option},
  otherkeywords={=>,<-,<\%,<:,>:,\#,@},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[n]{/*}{*/},
  morestring=[b]",
  morestring=[b]',
  morestring=[b]"""
}


\usepackage{color}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

% Default settings for code listings
\lstset{frame=tb,
  language=scala,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  frame=single,
  breaklines=true,
  breakatwhitespace=true
  tabsize=3
}

\begin{document}

\newcommand\type[1]{\texttt{#1}}
\newcommand\func[1]{\texttt{#1}}
\newcommand\code[1]{\texttt{#1}}
\renewcommand\value[1]{\texttt{#1}}
\newcommand\source[2]{See: \texttt{src/#1.scala}::\type{#2} \\}
\newcommand\testsrc[1]{See: \texttt{test/#1.scala} \\}

\maketitle

\section{Design}

\subsection{Resolver}
\subsubsection{Building the Package Tree}
also creates primitives

\subsubsection{Determining Type Scopes}
\subsubsection{Resolving Types}

\begin{lstlisting}[language=Scala]
\end{lstlisting}



\subsection{Knower}
\subsubsection{Inheritance Expansion}

\begin{lstlisting}[language=Scala]
lazy val (inheritedMethods: Seq[MethodDefn], hidesMethods: Seq[MethodDefn]) = {
  val parentMethods =
    extnds.flatMap(_.resolved.get.inheritedMethods).filter(!_.isCxr)
  val sigs = methods.map(_.signature)
  val (hides, keeps) = parentMethods.partition { parMeth =>
    sigs.contains(parMeth.signature)
  }

  (methods ++ keeps, hides)
}
\end{lstlisting}
\source{ast/AST}{TypeDefn}

\subsubsection{Interface Contract Verification}




\subsection{Scoper}
builds a scope table for every lexical scope
errors if things are defined multiple times in the same scope
notably doesn't determine what's in scope any given statement, which lead to some issues for analysis
but this approach was taken because it will simplify codegen's variable allocation
    refer to prober for implementation of this


\begin{lstlisting}[language=Scala]
node.visit { (self, context) =>
  self match {
    // ... other cases
    case Before(VarStmnt(name,_,tname,_)) =>
      if (curBlock != curClass && !curBlock.define(name, tname)) {
        // Already defined
        throw new ScopeError("Duplicate definition of variable \$name", self.from)
      }
    case Before(_: BlockStmnt) =>
      makeChildScope()
    case After(_: BlockStmnt) =>
      freeChildScope()
    case Before(_: WhileStmnt) =>
      makeChildScope()
    case After(_: WhileStmnt) =>
      freeChildScope()
  }
}
\end{lstlisting}
\source{scoper/Scoper}{Scoper\#apply}



\subsection{Disambiguator}
\subsubsection{Rewriter}
our generalized visitor strategy turned out to not be powerful enough to implement AST rewriting.
we briefly looked at implementing scrap your boilerplate in scala which would give us automatic traversals
over the AST (and notably, WOULD be strong enough), but the implementation turned out to be too much work
and overkill. we ended up just explicitly writing rewrite methods on every ast node type
realized that our current AST was amazingly unhelpful for some some use cases

for example, static method calls would be represented with
\begin{lstlisting}[language=Scala]
val staticCall = parse("pkg.Type.method()")
staticCall === Call(Member(Member(Id("pkg"), Id("Type")), Id("method")))
\end{lstlisting}
notably, this doesn't reflect the case that \code{pkg.Type} is not a member access, but instead
refers to a single ontological entity. this becomes much more of an issue with longer package names

\begin{lstlisting}[language=Scala]
def rewrite(rule: Rewriter, context: Seq[Visitable]) = {
  val newContext = this +: context
  transfer(rule(
    IfStmnt(
      cond.rewrite(rule, newContext).asInstanceOf[Expression],
      then.rewrite(rule, newContext).asInstanceOf[BlockStmnt],
      otherwise.map(_.rewrite(rule, newContext).asInstanceOf[BlockStmnt])
    ), context))
}
\end{lstlisting}
\source{ast/AST}{IfStmnt\#rewrite}

where rule is a partial function defined over AST nodes which returns what to replace the node with. for
a visit over the tree, the identity function will suffice

unfortunately this approach (but not SYB in general) loses type-safety, thus the instanceof casts in the
above code sample. in practice, this is not a huge issue, but is something to keep tabs on
(and unfortunately slows down our code at runtime)



\subsubsection{Static Disambiguation}
the disambiguator's goal is to solve the above issue with static accesses
we attempt to disambiguate every identifier in a member access chain, by following the rules in JLS (TODO: wahtever)
if something ever resolves to a type (with the same rules as in the resolver pass), we immediately transform it
into a static member access, and stop processing further

\begin{lstlisting}[language=Scala]
node.rewrite(Rewriter { (newNode: Visitable, context: Seq[Visitable]) =>
  implicit val implContext = context
  newNode match {
    // ... other cases
    case m: Member =>
      val folded =
        m.fold {
          case id: Id if id.status != SCOPE => Some(id)
          case _ => None
        }

      if (!folded.contains(None)) {
        val rhs = folded.flatten.last
        val path = folded.flatten.dropRight(1)
        val qname = path.map(_.name)

        if (path.last.status == TYPE) {
          val classDefn = node.resolve(qname, pkgtree, m.from).get

          // rewrite this member access with a static member access
          StaticMember(classDefn.asInstanceOf[ClassDefn], rhs)
        } else {
          disambiguate(rhs, qname)
          m
        }
      } else m
  }
}
\end{lstlisting}
\source{disambiguator/Disambiguator}{Disambiguator\#apply}



\subsection{Analysis Probe}
the analysis probe is responsible for checking field initialization order
also ensuring variables are in scope by the time they are used
    (since the scoper doesn't do this)
statement reachability
and method return
reachability is implemented by folding over the JLS rules for reachable and completing normally
since these turn out to be extraneous
    implemented as a tail-recursive walk over each lexical scope
    calling the next stmnt with whether or not it is reachable
        if this is ever false, we throw an error

\begin{lstlisting}[language=Scala]
private def probe(reachable: Boolean, stmnt: Statement): Boolean = {
  if (!reachable)
    throw UnreachableError(stmnt)

  stmnt match {
    case BlockStmnt(stmnts) =>
      (true /: stmnts)(probe)
    case IfStmnt(_, then, otherwise) =>
      if (otherwise.isDefined)
        probe(then) || probe(otherwise.get)
      else {
        probe(then)
        true
      }
    case WhileStmnt(cond, body) =>
      cond match {
        case BoolVal(true) => false
        case BoolVal(false) => probe(false, body)
        case _ => true
      }
    // ... other cases
\end{lstlisting}
\source{analysis/AnalysisProbe}{AnalysisProbe\#probe}



\subsection{Checker}
\subsubsection{Typechecking}
\subsubsection{Constant Folding}

\begin{lstlisting}[language=Scala]
\end{lstlisting}



\section{Challenges}
\begin{itemize}
    \item resolving is a bitch cause of spec
    \item rewriter
    \item scoper doesn't scope on a per-statement level
    \item checker should probably have been two passes
\end{itemize}




\section{Testing}

We've heavily depended on a strong testing infrastructure during the development of our code; at time of writing we have
a little over 70 unit tests. Because Scala has strong support for domain specific languages, scalatest is absolutely
lovely to use. Furthermore, the testing infrastructure is a first-class citizen, and so some of our later-stage tests
are capable of succinctly running A/B tests on code -- ensuring that text substitution changes the results from pass to
failure.

Our tests have been written from the bottom-up, marking very small units to be tested. Our philosophy has been
test-driven development, and on quite a few occasions this policy has prevented us from creating regression bugs.

An example of one of our parser tests looks like this:

\begin{lstlisting}[language=Scala]
"Parser" should "right-associate assignments" in {
  mkParser("a = b = 5").parseExpr() should be ===
    Assignment(
      Id("a"),
      Assignment(Id("b"), IntVal(5)))
}
\end{lstlisting}

\testsrc{*}

\end{document}

