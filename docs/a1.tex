\documentclass{article}
\usepackage{todonotes}
\usepackage{listings}

\title{CS 444 - A1}
\author{Jacob Abrahams - 20370104\\ Alexander Maguire - 20396195}

\lstdefinelanguage{scala}{
  morekeywords={abstract,case,catch,class,def,%
    do,else,extends,false,final,finally,%
    for,if,implicit,import,match,mixin,%
    new,null,object,override,package,%
    private,protected,requires,return,sealed,%
    super,this,throw,trait,true,try,%
    type,val,var,while,with,yield},
  otherkeywords={=>,<-,<\%,<:,>:,\#,@},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[n]{/*}{*/},
  morestring=[b]",
  morestring=[b]',
  morestring=[b]"""
}


\usepackage{color}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

% Default settings for code listings
\lstset{frame=tb,
  language=scala,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  frame=single,
  breaklines=true,
  breakatwhitespace=true
  tabsize=3
}

\begin{document}

\newcommand\type[1]{\texttt{#1}}
\renewcommand\value[1]{\texttt{#1}}
\newcommand\source[2]{See: \texttt{#1.scala}::\type{#2} \\}

\maketitle

\section{Design}


\subsection{Overview}


\subsection{Tokenizing}
\source{tokenizer/Tokenizer}{Tokenizer\#apply}
\todo{mention having source locations}




\subsection{Parsing}

\subsubsection{Overview}


\begin{lstlisting}[language=Scala]
def parseIf(): IfStmnt = withSource {
  ensure("if")
  ensure("(")
  val cond = parseExpr()
  ensure(")")
  val then = parseStmnt()

  val otherwise =
    if (check("else")) {
      ensure("else")
      Some(parseStmnt())
    } else None

  new IfStmnt(cond, then, otherwise)
}
\end{lstlisting}





\subsubsection{Compilation Unit}
\source{parser/Parser}{Parser\#parseFile}

\subsubsection{Statements}
\source{parser/Parser}{Parser\#parseStmnt}

\subsubsection{Expressions}
\source{parser/Parser}{Parser\#parseExpr}


\subsection{Abstract Syntax Tree}

\subsubsection{Overview}

\subsubsection{Visiting}
\source{utils/Visitor}{Visitable}

Our compiler takes a relatively novel approach to visiting the AST; all syntax nodes are derived from \type{Visitable}
-- an abstract trait whose \value{children} member acts as a manifest for which nodes are visitable from this node. To
visit over the AST, \type{Visitor} is given a \textit{visit function} and \textit{folding function}. The \textit{visit
function} is given either a \value{Before(Node)} or an \value{After(Node)}, as well as all of the \value{Node}'s
ancestors in the tree to allow for context-sensitivity. The \textit{visit function} returns a generic type \type{T},
and it is the responsibility of the \textit{folding function} to transform \type{List<T>} into a single \type{T}. For
example, the \textit{visit function} might return whether or not a node is valid, and the \textit{folding function}
would return the logical AND of all the booleans. The result of this visit would then be whether or not the entire AST
is valid.

Additionally, the \value{Visitor} lifts its function arguments to provide automatic error-handling; any exceptions
deriving from \type{CompilerError} thrown in the \textit{visit function} are caught and bundled together, allowing for
natural error handling while visiting, without sacrificing encapsulation.


\begin{lstlisting}[language=Scala]
ast.visit(_ && _) { (self, context) =>
  node match {
    case Before(MethodDefn(name, _, _, _, _)) =>
      println("Entering method " + name)
      true

    case After(MethodDefn(name, _, _, _, _)) =>
      println("Leaving method " + name)
      true

    case _ => true
  }
}


\end{lstlisting}




\subsubsection{Operators}
\source{ast/AST}{BinaryOperator}

\subsubsection{Literals}
\source{ast/AST}{\todo{}}






\subsection{Weeding}
\source{weeder/Weeder}{Weeder\#apply}




\section{Challenges}

\begin{itemize}
    \item no grammar
    \item forgot to parse constructors
    \item negative ints
    \item duplicate modifiers
    \item rewinding to parse
    \item visitor would reduce to a single value -- hard to return errors
    \item automatic binary expression precedence; made instanceof hacky
\end{itemize}




\section{Testing}

\begin{itemize}
    \item scala test. lots of unit tests. tons! like 70
    \item most of them are built from the bottom up, so we can just test individual expressions, for example
    \item scala lets us write high-level testing infrastructure, like AB testing with keywords for the weeder
\end{itemize}

\end{document}

